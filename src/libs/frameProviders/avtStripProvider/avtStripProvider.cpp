#include "avtStripProvider.h"
#include <QDirIterator>

#include "util.h"
#include "frameRef.h"

#include "ProcessParameters.h"

#include <thread>
#include <opencv2/imgcodecs.hpp>
#include <QDateTime>
#include "common/june_enums.h"
#include "natsort.h"

#ifdef _DEBUG
#pragma comment(lib, "opencv_world342d.lib")
#else
#pragma comment(lib, "opencv_world342.lib")
#endif


#define AVT_STRIP_PROVIDER_SCOPED_LOG PRINT_INFO6 << "[AVTProvider] : "
#define AVT_STRIP_PROVIDER_SCOPED_ERROR PRINT_ERROR << "[AVTProvider] : "
#define AVT_STRIP_PROVIDER_SCOPED_WARNING PRINT_WARNING << "[AVTProvider] : "

using namespace LandaJune;
using namespace Core;
using namespace Parameters;
using namespace FrameProviders;
using namespace Helpers;

static const QString AVT_STRIP_PROVIDER_NAME = "AVT Offline Strip Reader";
static const QString AVT_STRIP_PROVIDER_DESC = "AVT Offline Strip Reader reads images previously generated by AVT system";


avtStripProvider::avtStripProvider()
{
	_name = AVT_STRIP_PROVIDER_NAME;
	_description = AVT_STRIP_PROVIDER_DESC;
	AVT_STRIP_PROVIDER_SCOPED_LOG << "created";
}

avtStripProvider::~avtStripProvider()
{
	AVT_STRIP_PROVIDER_SCOPED_LOG << "destroyed";
}



void avtStripProvider::filterLeftRightOrphans(QStringList& pathList, int& orphanCount)
{
	orphanCount = 0;
	bool bLeftSide = true;
	QString currentLeftPath;

	auto prefixLambda = [](const QString& path)
	{
		QString retVal;
		// parse source path of form :
		// d:/Temp/JUNE/june_offline_input/JIG_300_default/1_911_Registration/GeometricRegInf28_15/GeometricRegInf28_15layoutImg.bmp
		QStringList elements  = QDir::fromNativeSeparators(path).split('/');
		if (elements.size() >= 4)
		{
			// should be of form : 1_911
			QStringList parts = elements[elements.size() - 3].split('_');
			if (!parts.empty() )
			{
				retVal = parts[0];
			}
		}
		return retVal;
	};

	for ( const auto& framePath : pathList)
	{
		if (bLeftSide)
		{
			currentLeftPath = framePath;
		}
		else
		{
			if( prefixLambda(currentLeftPath) == prefixLambda(framePath))
			{
				_imagePathsLeft << currentLeftPath;
				_imagePathsRight << framePath;
			}
			else
			{
				++orphanCount;
				AVT_STRIP_PROVIDER_SCOPED_WARNING << "Found orphan image : " << currentLeftPath << "; skipping...";
			}
		}
		bLeftSide = !bLeftSide;
	}
}


void avtStripProvider::sortImageFileList( QStringList& pathList )
{
	std::sort(pathList.begin(), pathList.end(), 
			[](const QString& left, const QString& right) 
			{
				auto ls = left.toStdString();
				auto rs = right.toStdString();
				return natural_compare(ls, rs);
			});
}

void avtStripProvider::init(BaseParametersPtr parameters, Core::ICore * coreObject, CoreEventCallback callback)
{
	try
	{
		validateParameters(parameters);
		connect (parameters.get(), &BaseParameters::updateCalculated, this, &BaseFrameProvider::onUpdateParameters);
		
		_dataCallback = callback;
		_coreObject = coreObject;
			
		_lastAcquiredImage = -1;

		_imagePathsLeft.clear();
		_imagePathsRight.clear();
		
		const auto imageFolder = _SourceFolderPath; 
		if ( imageFolder.isEmpty() || !QFileInfo(imageFolder).exists())
		{
			AVT_STRIP_PROVIDER_SCOPED_ERROR << "Source folder " << imageFolder << " invalid or cannot be found. Aborting scan...";
			THROW_EX_ERR_STR(CORE_ERROR::ERR_OFFLINE_READER_SOURCE_FILE_INVALID, "Source folder invalid or cannot be found : " + imageFolder.toStdString() );
		}

		QStringList imagePaths;
		AVT_STRIP_PROVIDER_SCOPED_LOG << "Scanning for source files at " << imageFolder << "...";
		QDirIterator it(imageFolder, QStringList() << "*.bmp" << "*.BMP", QDir::Files, QDirIterator::Subdirectories);

		while (it.hasNext()) 
		{
			imagePaths.push_back(it.next());
		}
		
		AVT_STRIP_PROVIDER_SCOPED_LOG << "found " << imagePaths.size() << " files. Sorting...";
		if (imagePaths.isEmpty())
		{
			AVT_STRIP_PROVIDER_SCOPED_LOG << "Source folder " << imageFolder << " contains no viable files";
			THROW_EX_ERR_STR(CORE_ERROR::ERR_OFFLINE_READER_NO_FILES_TO_LOAD, "Source folder icontains no files for loading : " + imageFolder.toStdString() );
		}

		sortImageFileList(imagePaths);
		
		AVT_STRIP_PROVIDER_SCOPED_LOG << "sorting complete. Splitting to left and right and filtering out single frames...";
		int orphanCount = 0;
		filterLeftRightOrphans(imagePaths, orphanCount);
		AVT_STRIP_PROVIDER_SCOPED_LOG << "Filtering complete. Found " << orphanCount << " orphans";

		if (_dataCallback)
		{
			int itemsToReport = ( _ImageMaxCount > 0 ) ? qMin(_imagePathsLeft.size(), _ImageMaxCount) : _imagePathsLeft.size();
			_dataCallback(_coreObject, CoreCallbackType::CALLBACK_PROVIDER_SCANNED_FILES_COUNT, std::make_any<int>(itemsToReport));
		}
	}
	catch(BaseException& bex)
	{
		throw;
	}
	catch ( std::exception& ex )
	{
		RETHROW( CORE_ERROR::ERR_PROVIDER_FAILED_TO_INIT);
	}
}

void avtStripProvider::cleanup()
{
	try
	{
		disconnect (_providerParameters.get(), &BaseParameters::updateCalculated, this, &BaseFrameProvider::onUpdateParameters);
		_imagePathsLeft.clear();
		_imagePathsRight.clear();
		_coreObject = nullptr;
		_dataCallback = nullptr;
		_providerParameters.reset();

		AVT_STRIP_PROVIDER_SCOPED_LOG << "cleaned up";
	}
	catch(BaseException& bex)
	{
		throw;
	}
	catch ( std::exception& ex )
	{
		RETHROW( CORE_ERROR::ERR_PROVIDER_CLEANUP_FAILED);
	}
}


void avtStripProvider::validateParameters(BaseParametersPtr parameters)
{
	// TODO : query BaseParameters for named parameters
	// currently hardcoded

	const auto processParams = std::dynamic_pointer_cast<ProcessParameters>(parameters);

	_SourceFolderPath = processParams->SourceFolderPath();
	_ImageMaxCount = processParams->ImageMaxCount();
	
	AVT_STRIP_PROVIDER_SCOPED_LOG << "Validating provider parameters : ";
	AVT_STRIP_PROVIDER_SCOPED_LOG << "---------------------------------------";
	AVT_STRIP_PROVIDER_SCOPED_LOG << "_SourceFolderPath = " << _SourceFolderPath;
	AVT_STRIP_PROVIDER_SCOPED_LOG << "_ImageMaxCount = " << _ImageMaxCount;

	_providerParameters = parameters;
}

int32_t avtStripProvider::getFrameLifeSpan() const
{
	const auto processParams = std::dynamic_pointer_cast<ProcessParameters>(_providerParameters);
	return processParams->FrameFrequencyInMSec();
}

CORE_ERROR avtStripProvider::prepareData(FrameRef* frameRef)
{
	// AVT strip provider relies on fact, that source iages alwys come in pairs ( after sorting and filtering )
	// so, if right strip array is empty, there is no more files to produce
	if (_imagePathsRight.empty())
	{
		AVT_STRIP_PROVIDER_SCOPED_LOG << "No more files to handle. Exiting...";
		return CORE_ERROR::ERR_OFFLINE_READER_NO_MORE_FILES;
	}

	if (_ImageMaxCount > 0 &&  _lastAcquiredImage == _ImageMaxCount -1 )
	{
		AVT_STRIP_PROVIDER_SCOPED_LOG << "Reached a maximum number of requested images. Exiting...";
		return CORE_ERROR::ERR_OFFLINE_READER_REACHED_MAX_COUNT;
	}
	std::this_thread::sleep_for(std::chrono::milliseconds(100));
	return RESULT_OK;
}

CORE_ERROR avtStripProvider::accessData(FrameRef* frameRef)
{
	// read image to cv::Mat object

	auto& pathList = (_bCurrentLeftSide) ? _imagePathsLeft : _imagePathsRight;
	
	QString srcFullPath = pathList.first();
	pathList.pop_front();
	
	AVT_STRIP_PROVIDER_SCOPED_LOG << "loading source file " << srcFullPath << "...";

	const auto& stdPath = srcFullPath.toStdString();

	const auto tempMatObject = std::make_shared<cv::Mat>(cv::imread(srcFullPath.toStdString()));
	if (!tempMatObject->data)            // Check for invalid input
	{
		AVT_STRIP_PROVIDER_SCOPED_WARNING << "Cannot load image " << srcFullPath;
		return CORE_ERROR::ERR_OFFLINE_READER_SOURCE_FILE_INVALID;
	}

	AVT_STRIP_PROVIDER_SCOPED_LOG << "Image " << srcFullPath << " has been loaded successfully to frameRef #" << frameRef->getFrameRefIndex();

	if (_bCurrentLeftSide)
		++_lastAcquiredImage;

	frameRef->setBits(_lastAcquiredImage, tempMatObject);

	// this flag tells the algorithm runner to perform
	// image/CSV saving synchronously 
	// to avoid save queue growing constantly
	// for offline analysis it's not critical to perform saving synchronously

	// TODO : replace this function/member to derivative of offline/online generated bits ?
	frameRef->setAsyncWrite(false);

	// pass source image path to frame
	frameRef->setNamedParameter(NAMED_PROPERTY_SOURCE_PATH, stdPath);

	// set side hint in case of strip provider
	(_bCurrentLeftSide) ? frameRef->setNamedParameter(NAMED_PROPERTY_FRAME_PARITY, 1) : frameRef->setNamedParameter(NAMED_PROPERTY_FRAME_PARITY, 0);
	_bCurrentLeftSide = !_bCurrentLeftSide;

	return RESULT_OK;
}